package main

import (
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"regexp"
	"strings"
)

func main() {
	pkg := flag.String("pkg", "", "package name to generate for")
	dir := flag.String("dir", ".", "directory of the package to scan")
	tag := flag.String("tag", "json", "struct tag key to use for map keys")
	out := flag.String("out", "gen_map.go", "output file name")
	exclude := flag.String("exclude", "", "comma-separated list of type names to exclude from generation")
	flag.Parse()

	if *pkg == "" {
		fatal("-pkg is required")
	}

	excludeSet := make(map[string]struct{})
	if *exclude != "" {
		for _, n := range strings.Split(*exclude, ",") {
			name := strings.TrimSpace(n)
			if name != "" {
				excludeSet[name] = struct{}{}
			}
		}
	}

	fset := token.NewFileSet()
	pkgs, err := parser.ParseDir(fset, *dir, func(info os.FileInfo) bool {
		// skip test and generated artifacts
		return !strings.HasSuffix(info.Name(), "_test.go") && !strings.HasSuffix(info.Name(), ".gen.go")
	}, parser.ParseComments)
	if err != nil {
		fatal("parse dir: %v", err)
	}

	p, ok := pkgs[*pkg]
	if !ok {
		// fallback: if dir has single package, use it
		if len(pkgs) == 1 {
			for name := range pkgs {
				p = pkgs[name]
				ok = true
				break
			}
		}
	}
	if !ok || p == nil {
		fatal("package %s not found in %s", *pkg, *dir)
	}

	structs := make(map[string]*ast.StructType)
	ast.Inspect(p, func(n ast.Node) bool {
		ts, ok := n.(*ast.TypeSpec)
		if !ok || ts.Name == nil {
			return true
		}
		st, ok := ts.Type.(*ast.StructType)
		if !ok {
			return true
		}
		// only exported types and not excluded
		if isExported(ts.Name.Name) {
			if _, skip := excludeSet[ts.Name.Name]; !skip {
				structs[ts.Name.Name] = st
			}
		}
		return true
	})

	if len(structs) == 0 {
		fatal("no exported structs found in %s", *dir)
	}

	var b strings.Builder
	b.WriteString("// Code generated by genmap; DO NOT EDIT.\n")
	b.WriteString("package ")
	b.WriteString(*pkg)
	b.WriteString("\n\n")
	// any is used; requires go1.18+
	b.WriteString("// Generated mapping helpers for struct -> map[string]any using tag: ")
	b.WriteString(*tag)
	b.WriteString("\n")

	for name, st := range structs {
		generateToMap(&b, name, st, *tag)
	}

	outPath := filepath.Join(*dir, *out)
	if err := os.WriteFile(outPath, []byte(b.String()), 0644); err != nil {
		fatal("write file: %v", err)
	}
}

func generateToMap(b *strings.Builder, typeName string, st *ast.StructType, tag string) {
	methodName := "ToMap"
	b.WriteString(fmt.Sprintf("func (s *%s) %s() map[string]any {\n", typeName, methodName))
	b.WriteString("\tres := make(map[string]any, ")
	b.WriteString(fmt.Sprintf("%d)", countExportedFields(st)))
	b.WriteString("\n")

	for _, f := range st.Fields.List {
		// handle anonymous embedded fields
		if len(f.Names) == 0 {
			// exported embedded types (value or pointer)
			if ident, ok := f.Type.(*ast.Ident); ok && isExported(ident.Name) {
				b.WriteString(fmt.Sprintf("\tfor k, v := range s.%s.%s() { res[k] = v }\n", ident.Name, "ToMap"))
			} else if star, ok := f.Type.(*ast.StarExpr); ok {
				if id, ok := star.X.(*ast.Ident); ok && isExported(id.Name) {
					b.WriteString(fmt.Sprintf("\tif s.%s != nil { for k, v := range s.%s.%s() { res[k] = v } }\n", id.Name, id.Name, "ToMap"))
				}
			}
			continue
		}
		name := f.Names[0].Name
		if !isExported(name) { // skip unexported
			continue
		}
		key := name
		if f.Tag != nil {
			parsed := parseTag(strings.Trim(f.Tag.Value, "`"), tag)
			if parsed == "-" {
				continue
			}
			if parsed != "" {
				key = parsed
			}
		}
		if isStringType(f.Type) {
			b.WriteString(fmt.Sprintf("\tif s.%s != \"\" { res[%q] = s.%s }\n", name, key, name))
		} else {
			b.WriteString(fmt.Sprintf("\tres[%q] = s.%s\n", key, name))
		}
	}
	b.WriteString("\treturn res\n}\n\n")
}

func isStringType(expr ast.Expr) bool {
	if id, ok := expr.(*ast.Ident); ok {
		return id.Name == "string"
	}
	return false
}

func countExportedFields(st *ast.StructType) int {
	c := 0
	for _, f := range st.Fields.List {
		if len(f.Names) == 0 {
			// embedded - count as multiple unknown; leave capacity as heuristic
			continue
		}
		if isExported(f.Names[0].Name) {
			c++
		}
	}
	return c
}

func isExported(name string) bool {
	if name == "" {
		return false
	}
	r := name[0]
	return r >= 'A' && r <= 'Z'
}

var tagRe = regexp.MustCompile(`(?:^|\s)([a-zA-Z0-9_]+):\"([^\"]*)\"`)

func parseTag(tagLiteral string, key string) string {
	// find key:"value"
	for _, m := range tagRe.FindAllStringSubmatch(tagLiteral, -1) {
		if len(m) >= 3 && m[1] == key {
			v := m[2]
			if i := strings.IndexByte(v, ','); i >= 0 {
				v = v[:i]
			}
			return v
		}
	}
	return ""
}

func fatal(format string, a ...any) {
	fmt.Fprintf(os.Stderr, format+"\n", a...)
	os.Exit(1)
}
