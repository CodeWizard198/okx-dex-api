// Code generated by genmap; DO NOT EDIT.
package okxdexapi

// Generated mapping helpers for struct -> map[string]any using tag: json
func (s *ApproveTransactionRequest) ToMap() map[string]any {
	res := make(map[string]any, 3)
	if s.ChainIndex != "" { res["chainIndex"] = s.ChainIndex }
	if s.TokenContractAddress != "" { res["tokenContractAddress"] = s.TokenContractAddress }
	if s.ApproveAmount != "" { res["approveAmount"] = s.ApproveAmount }
	return res
}

func (s *SwapInstructionResponse) ToMap() map[string]any {
	res := make(map[string]any, 4)
	res["addressLookupTableAccount"] = s.AddressLookupTableAccount
	res["instructionLists"] = s.InstructionLists
	res["routerResult"] = s.RouterResult
	res["tx"] = s.Tx
	return res
}

func (s *AllTokenBalanceByAddressRequest) ToMap() map[string]any {
	res := make(map[string]any, 3)
	if s.Address != "" { res["address"] = s.Address }
	if s.Chains != "" { res["chains"] = s.Chains }
	if s.ExcludeRiskToken != "" { res["excludeRiskToken"] = s.ExcludeRiskToken }
	return res
}

func (s *TransactionByAddressRequest) ToMap() map[string]any {
	res := make(map[string]any, 7)
	if s.Address != "" { res["address"] = s.Address }
	if s.Chains != "" { res["chains"] = s.Chains }
	if s.TokenContractAddress != "" { res["tokenContractAddress"] = s.TokenContractAddress }
	if s.Begin != "" { res["begin"] = s.Begin }
	if s.End != "" { res["end"] = s.End }
	if s.Cursor != "" { res["cursor"] = s.Cursor }
	if s.Limit != "" { res["limit"] = s.Limit }
	return res
}

func (s *MarketTokenBasicInfoResponse) ToMap() map[string]any {
	res := make(map[string]any, 7)
	if s.ChainIndex != "" { res["chainIndex"] = s.ChainIndex }
	if s.Decimal != "" { res["decimal"] = s.Decimal }
	res["tagList"] = s.TagList
	if s.TokenContractAddress != "" { res["tokenContractAddress"] = s.TokenContractAddress }
	if s.TokenLogoUrl != "" { res["tokenLogoUrl"] = s.TokenLogoUrl }
	if s.TokenName != "" { res["tokenName"] = s.TokenName }
	if s.TokenSymbol != "" { res["tokenSymbol"] = s.TokenSymbol }
	return res
}

func (s *MarketPriceInfoRequest) ToMap() map[string]any {
	res := make(map[string]any, 2)
	if s.ChainIndex != "" { res["chainIndex"] = s.ChainIndex }
	if s.TokenContractAddress != "" { res["tokenContractAddress"] = s.TokenContractAddress }
	return res
}

func (s *SwapResponse) ToMap() map[string]any {
	res := make(map[string]any, 2)
	res["routerResult"] = s.RouterResult
	res["tx"] = s.Tx
	return res
}

func (s *AllTokenBalanceByAddressResponse) ToMap() map[string]any {
	res := make(map[string]any, 1)
	res["tokenAssets"] = s.TokenAssets
	return res
}

func (s *TokenBalanceByAddressResponse) ToMap() map[string]any {
	res := make(map[string]any, 1)
	res["tokenAssets"] = s.TokenAssets
	return res
}

func (s *GasPriceRequest) ToMap() map[string]any {
	res := make(map[string]any, 1)
	if s.ChainIndex != "" { res["chainIndex"] = s.ChainIndex }
	return res
}

func (s *CurrentPriceRequest) ToMap() map[string]any {
	res := make(map[string]any, 2)
	if s.ChainIndex != "" { res["chainIndex"] = s.ChainIndex }
	if s.TokenContractAddress != "" { res["tokenContractAddress"] = s.TokenContractAddress }
	return res
}

func (s *TransactionByAddressResponse) ToMap() map[string]any {
	res := make(map[string]any, 2)
	if s.Cursor != "" { res["cursor"] = s.Cursor }
	res["transactions"] = s.Transactions
	return res
}

func (s *MarketTokenToplistResponse) ToMap() map[string]any {
	res := make(map[string]any, 15)
	if s.ChainIndex != "" { res["chainIndex"] = s.ChainIndex }
	if s.Change != "" { res["change"] = s.Change }
	if s.FirstTradeTime != "" { res["firstTradeTime"] = s.FirstTradeTime }
	if s.Holders != "" { res["holders"] = s.Holders }
	if s.Liquidity != "" { res["liquidity"] = s.Liquidity }
	if s.MarketCap != "" { res["marketCap"] = s.MarketCap }
	if s.Price != "" { res["price"] = s.Price }
	if s.TokenContractAddress != "" { res["tokenContractAddress"] = s.TokenContractAddress }
	if s.TokenLogoUrl != "" { res["tokenLogoUrl"] = s.TokenLogoUrl }
	if s.TokenSymbol != "" { res["tokenSymbol"] = s.TokenSymbol }
	if s.Txs != "" { res["txs"] = s.Txs }
	if s.TxsBuy != "" { res["txsBuy"] = s.TxsBuy }
	if s.TxsSell != "" { res["txsSell"] = s.TxsSell }
	if s.UniqueTraders != "" { res["uniqueTraders"] = s.UniqueTraders }
	if s.Volume != "" { res["volume"] = s.Volume }
	return res
}

func (s *ApproveTransactionResponse) ToMap() map[string]any {
	res := make(map[string]any, 4)
	if s.Data != "" { res["data"] = s.Data }
	if s.DexContractAddress != "" { res["dexContractAddress"] = s.DexContractAddress }
	if s.GasLimit != "" { res["gasLimit"] = s.GasLimit }
	if s.GasPrice != "" { res["gasPrice"] = s.GasPrice }
	return res
}

func (s *SwapInstructionRequest) ToMap() map[string]any {
	res := make(map[string]any, 21)
	if s.ChainIndex != "" { res["chainIndex"] = s.ChainIndex }
	if s.Amount != "" { res["amount"] = s.Amount }
	if s.FromTokenAddress != "" { res["fromTokenAddress"] = s.FromTokenAddress }
	if s.ToTokenAddress != "" { res["toTokenAddress"] = s.ToTokenAddress }
	if s.SlippagePercent != "" { res["slippagePercent"] = s.SlippagePercent }
	res["autoSlippage"] = s.AutoSlippage
	if s.MaxAutoSlippage != "" { res["maxAutoSlippage"] = s.MaxAutoSlippage }
	if s.UserWalletAddress != "" { res["userWalletAddress"] = s.UserWalletAddress }
	if s.SwapReceiverAddress != "" { res["swapReceiverAddress"] = s.SwapReceiverAddress }
	if s.FeePercent != "" { res["feePercent"] = s.FeePercent }
	if s.FromTokenReferrerWalletAddress != "" { res["fromTokenReferrerWalletAddress"] = s.FromTokenReferrerWalletAddress }
	if s.ToTokenReferrerWalletAddress != "" { res["toTokenReferrerWalletAddress"] = s.ToTokenReferrerWalletAddress }
	if s.PositiveSlippagePercent != "" { res["positiveSlippagePercent"] = s.PositiveSlippagePercent }
	if s.PositiveSlippageFeeAddress != "" { res["positiveSlippageFeeAddress"] = s.PositiveSlippageFeeAddress }
	if s.DexIds != "" { res["dexIds"] = s.DexIds }
	if s.ExcludeDexIds != "" { res["excludeDexIds"] = s.ExcludeDexIds }
	if s.DisableRFQ != "" { res["disableRFQ"] = s.DisableRFQ }
	res["directRoute"] = s.DirectRoute
	if s.PriceImpactProtectionPercentage != "" { res["priceImpactProtectionPercentage"] = s.PriceImpactProtectionPercentage }
	if s.ComputeUnitPrice != "" { res["computeUnitPrice"] = s.ComputeUnitPrice }
	if s.ComputeUnitLimit != "" { res["computeUnitLimit"] = s.ComputeUnitLimit }
	return res
}

func (s *GasPriceResponse) ToMap() map[string]any {
	res := make(map[string]any, 6)
	if s.Normal != "" { res["normal"] = s.Normal }
	if s.Min != "" { res["min"] = s.Min }
	if s.Max != "" { res["max"] = s.Max }
	res["supportEip1559"] = s.SupportEip1559
	res["eip1559Protocol"] = s.Eip1559Protocol
	res["priorityFee"] = s.PriorityFee
	return res
}

func (s *MarketTokenHolderResponse) ToMap() map[string]any {
	res := make(map[string]any, 2)
	if s.HoldAmount != "" { res["holdAmount"] = s.HoldAmount }
	if s.HolderWalletAddress != "" { res["holderWalletAddress"] = s.HolderWalletAddress }
	return res
}

func (s *MarketTokenSearchRequest) ToMap() map[string]any {
	res := make(map[string]any, 2)
	if s.Chains != "" { res["chains"] = s.Chains }
	if s.Search != "" { res["search"] = s.Search }
	return res
}

func (s *MarketTokenHolderRequest) ToMap() map[string]any {
	res := make(map[string]any, 2)
	if s.ChainIndex != "" { res["chainIndex"] = s.ChainIndex }
	if s.TokenContractAddress != "" { res["tokenContractAddress"] = s.TokenContractAddress }
	return res
}

func (s *QuoteRequest) ToMap() map[string]any {
	res := make(map[string]any, 9)
	if s.ChainIndex != "" { res["chainIndex"] = s.ChainIndex }
	if s.Amount != "" { res["amount"] = s.Amount }
	if s.SwapMode != "" { res["swapMode"] = s.SwapMode }
	if s.FromTokenAddress != "" { res["fromTokenAddress"] = s.FromTokenAddress }
	if s.ToTokenAddress != "" { res["toTokenAddress"] = s.ToTokenAddress }
	if s.DexIds != "" { res["dexIds"] = s.DexIds }
	res["directRoute"] = s.DirectRoute
	if s.PriceImpactProtectionPercentage != "" { res["priceImpactProtectionPercentage"] = s.PriceImpactProtectionPercentage }
	if s.FeePercent != "" { res["feePercent"] = s.FeePercent }
	return res
}

func (s *QuoteResponse) ToMap() map[string]any {
	res := make(map[string]any, 12)
	if s.ChainId != "" { res["chainId"] = s.ChainId }
	res["dexRouterList"] = s.DexRouterList
	if s.EstimateGasFee != "" { res["estimateGasFee"] = s.EstimateGasFee }
	res["fromToken"] = s.FromToken
	if s.FromTokenAmount != "" { res["fromTokenAmount"] = s.FromTokenAmount }
	if s.OriginToTokenAmount != "" { res["originToTokenAmount"] = s.OriginToTokenAmount }
	if s.PriceImpactPercentage != "" { res["priceImpactPercentage"] = s.PriceImpactPercentage }
	res["quoteCompareList"] = s.QuoteCompareList
	if s.SwapMode != "" { res["swapMode"] = s.SwapMode }
	res["toToken"] = s.ToToken
	if s.ToTokenAmount != "" { res["toTokenAmount"] = s.ToTokenAmount }
	if s.TradeFee != "" { res["tradeFee"] = s.TradeFee }
	return res
}

func (s *SwapRequest) ToMap() map[string]any {
	res := make(map[string]any, 26)
	if s.ChainIndex != "" { res["chainIndex"] = s.ChainIndex }
	if s.Amount != "" { res["amount"] = s.Amount }
	if s.SwapMode != "" { res["swapMode"] = s.SwapMode }
	if s.FromTokenAddress != "" { res["fromTokenAddress"] = s.FromTokenAddress }
	if s.ToTokenAddress != "" { res["toTokenAddress"] = s.ToTokenAddress }
	if s.SlippagePercent != "" { res["slippagePercent"] = s.SlippagePercent }
	if s.UserWalletAddress != "" { res["userWalletAddress"] = s.UserWalletAddress }
	if s.SwapReceiverAddress != "" { res["swapReceiverAddress"] = s.SwapReceiverAddress }
	if s.FeePercent != "" { res["feePercent"] = s.FeePercent }
	if s.FromTokenReferrerWalletAddress != "" { res["fromTokenReferrerWalletAddress"] = s.FromTokenReferrerWalletAddress }
	if s.ToTokenReferrerWalletAddress != "" { res["toTokenReferrerWalletAddress"] = s.ToTokenReferrerWalletAddress }
	if s.PositiveSlippagePercent != "" { res["positiveSlippagePercent"] = s.PositiveSlippagePercent }
	if s.PositiveSlippageFeeAddress != "" { res["positiveSlippageFeeAddress"] = s.PositiveSlippageFeeAddress }
	if s.Gaslimit != "" { res["gaslimit"] = s.Gaslimit }
	if s.GasLevel != "" { res["gasLevel"] = s.GasLevel }
	if s.DexIds != "" { res["dexIds"] = s.DexIds }
	res["directRoute"] = s.DirectRoute
	if s.CallDataMemo != "" { res["callDataMemo"] = s.CallDataMemo }
	if s.ComputeUnitPrice != "" { res["computeUnitPrice"] = s.ComputeUnitPrice }
	if s.ComputeUnitLimit != "" { res["computeUnitLimit"] = s.ComputeUnitLimit }
	if s.Tips != "" { res["tips"] = s.Tips }
	if s.ExcludeDexIds != "" { res["excludeDexIds"] = s.ExcludeDexIds }
	if s.DisableRFQ != "" { res["disableRFQ"] = s.DisableRFQ }
	if s.PriceImpactProtectionPercentage != "" { res["priceImpactProtectionPercentage"] = s.PriceImpactProtectionPercentage }
	res["autoSlippage"] = s.AutoSlippage
	if s.MaxAutoSlippage != "" { res["maxAutoSlippage"] = s.MaxAutoSlippage }
	return res
}

func (s *CurrentPriceResponse) ToMap() map[string]any {
	res := make(map[string]any, 4)
	if s.ChainIndex != "" { res["chainIndex"] = s.ChainIndex }
	if s.TokenContractAddress != "" { res["tokenContractAddress"] = s.TokenContractAddress }
	if s.Time != "" { res["time"] = s.Time }
	if s.Price != "" { res["price"] = s.Price }
	return res
}

func (s *MarketTokenSearchResponse) ToMap() map[string]any {
	res := make(map[string]any, 13)
	if s.ChainIndex != "" { res["chainIndex"] = s.ChainIndex }
	if s.Change != "" { res["change"] = s.Change }
	if s.Decimal != "" { res["decimal"] = s.Decimal }
	if s.ExplorerUrl != "" { res["explorerUrl"] = s.ExplorerUrl }
	if s.Holders != "" { res["holders"] = s.Holders }
	if s.Liquidity != "" { res["liquidity"] = s.Liquidity }
	if s.MarketCap != "" { res["marketCap"] = s.MarketCap }
	if s.Price != "" { res["price"] = s.Price }
	res["tagList"] = s.TagList
	if s.TokenContractAddress != "" { res["tokenContractAddress"] = s.TokenContractAddress }
	if s.TokenLogoUrl != "" { res["tokenLogoUrl"] = s.TokenLogoUrl }
	if s.TokenName != "" { res["tokenName"] = s.TokenName }
	if s.TokenSymbol != "" { res["tokenSymbol"] = s.TokenSymbol }
	return res
}

func (s *MarketTokenBasicInfoRequest) ToMap() map[string]any {
	res := make(map[string]any, 2)
	if s.ChainIndex != "" { res["chainIndex"] = s.ChainIndex }
	if s.TokenContractAddress != "" { res["tokenContractAddress"] = s.TokenContractAddress }
	return res
}

func (s *DexClient) ToMap() map[string]any {
	res := make(map[string]any, 0)
	return res
}

func (s *TokenBalanceByAddressRequest) ToMap() map[string]any {
	res := make(map[string]any, 3)
	if s.Address != "" { res["address"] = s.Address }
	res["tokenContractAddresses"] = s.TokenContractAddresses
	if s.ExcludeRiskToken != "" { res["excludeRiskToken"] = s.ExcludeRiskToken }
	return res
}

func (s *MarketPriceInfoResponse) ToMap() map[string]any {
	res := make(map[string]any, 23)
	if s.ChainIndex != "" { res["chainIndex"] = s.ChainIndex }
	if s.CircSupply != "" { res["circSupply"] = s.CircSupply }
	if s.Holders != "" { res["holders"] = s.Holders }
	if s.Liquidity != "" { res["liquidity"] = s.Liquidity }
	if s.MarketCap != "" { res["marketCap"] = s.MarketCap }
	if s.MaxPrice != "" { res["maxPrice"] = s.MaxPrice }
	if s.MinPrice != "" { res["minPrice"] = s.MinPrice }
	if s.Price != "" { res["price"] = s.Price }
	if s.PriceChange1H != "" { res["priceChange1H"] = s.PriceChange1H }
	if s.PriceChange24H != "" { res["priceChange24H"] = s.PriceChange24H }
	if s.PriceChange4H != "" { res["priceChange4H"] = s.PriceChange4H }
	if s.PriceChange5M != "" { res["priceChange5M"] = s.PriceChange5M }
	if s.Time != "" { res["time"] = s.Time }
	if s.TokenContractAddress != "" { res["tokenContractAddress"] = s.TokenContractAddress }
	if s.TradeNum != "" { res["tradeNum"] = s.TradeNum }
	if s.Txs1H != "" { res["txs1H"] = s.Txs1H }
	if s.Txs24H != "" { res["txs24H"] = s.Txs24H }
	if s.Txs4H != "" { res["txs4H"] = s.Txs4H }
	if s.Txs5M != "" { res["txs5M"] = s.Txs5M }
	if s.Volume1H != "" { res["volume1H"] = s.Volume1H }
	if s.Volume24H != "" { res["volume24H"] = s.Volume24H }
	if s.Volume4H != "" { res["volume4H"] = s.Volume4H }
	if s.Volume5M != "" { res["volume5M"] = s.Volume5M }
	return res
}

func (s *MarketTokenToplistRequest) ToMap() map[string]any {
	res := make(map[string]any, 3)
	if s.Chains != "" { res["chains"] = s.Chains }
	if s.SortBy != "" { res["sortBy"] = s.SortBy }
	if s.TimeFrame != "" { res["timeFrame"] = s.TimeFrame }
	return res
}

func (s *RequestParameters) ToMap() map[string]any {
	res := make(map[string]any, 4)
	res["Method"] = s.Method
	if s.Endpoint != "" { res["Endpoint"] = s.Endpoint }
	res["Params"] = s.Params
	res["Body"] = s.Body
	return res
}

func (s *DexConfig) ToMap() map[string]any {
	res := make(map[string]any, 5)
	if s.APIKey != "" { res["APIKey"] = s.APIKey }
	if s.SecretKey != "" { res["SecretKey"] = s.SecretKey }
	if s.Passphrase != "" { res["Passphrase"] = s.Passphrase }
	if s.BaseURL != "" { res["BaseURL"] = s.BaseURL }
	res["Timeout"] = s.Timeout
	return res
}

